/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/@microsoft/signalr@8.0.7/dist/esm/HubConnection.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{HandshakeProtocol}from"./HandshakeProtocol";import{AbortError}from"./Errors";import{MessageType}from"./IHubProtocol";import{LogLevel}from"./ILogger";import{Subject}from"./Subject";import{Arg,getErrorString,Platform}from"./Utils";import{MessageBuffer}from"./MessageBuffer";const DEFAULT_TIMEOUT_IN_MS=3e4,DEFAULT_PING_INTERVAL_IN_MS=15e3,DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE=1e5;export var HubConnectionState;!function(e){e.Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Disconnecting="Disconnecting",e.Reconnecting="Reconnecting"}(HubConnectionState||(HubConnectionState={}));export class HubConnection{static create(e,t,n,o,i,s,r){return new HubConnection(e,t,n,o,i,s,r)}constructor(e,t,n,o,i,s,r){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(LogLevel.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},Arg.isRequired(e,"connection"),Arg.isRequired(t,"logger"),Arg.isRequired(n,"protocol"),this.serverTimeoutInMilliseconds=null!=i?i:3e4,this.keepAliveIntervalInMilliseconds=null!=s?s:15e3,this._statefulReconnectBufferSize=null!=r?r:1e5,this._logger=t,this._protocol=n,this.connection=e,this._reconnectPolicy=o,this._handshakeProtocol=new HandshakeProtocol,this.connection.onreceive=e=>this._processIncomingData(e),this.connection.onclose=e=>this._connectionClosed(e),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:MessageType.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(e){if(this._connectionState!==HubConnectionState.Disconnected&&this._connectionState!==HubConnectionState.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!e)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=e}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==HubConnectionState.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=HubConnectionState.Connecting,this._logger.log(LogLevel.Debug,"Starting HubConnection.");try{await this._startInternal(),Platform.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=HubConnectionState.Connected,this._connectionStarted=!0,this._logger.log(LogLevel.Debug,"HubConnection connected successfully.")}catch(e){return this._connectionState=HubConnectionState.Disconnected,this._logger.log(LogLevel.Debug,`HubConnection failed to start successfully because of error '${e}'.`),Promise.reject(e)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;const e=new Promise(((e,t)=>{this._handshakeResolver=e,this._handshakeRejecter=t}));await this.connection.start(this._protocol.transferFormat);try{let t=this._protocol.version;this.connection.features.reconnect||(t=1);const n={protocol:this._protocol.name,version:t};if(this._logger.log(LogLevel.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(n)),this._logger.log(LogLevel.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await e,this._stopDuringStartError)throw this._stopDuringStartError;(this.connection.features.reconnect||!1)&&(this._messageBuffer=new MessageBuffer(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(e){throw this._logger.log(LogLevel.Debug,`Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(e),e}}async stop(){const e=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await e}catch(e){}}_stopInternal(e){if(this._connectionState===HubConnectionState.Disconnected)return this._logger.log(LogLevel.Debug,`Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===HubConnectionState.Disconnecting)return this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;const t=this._connectionState;return this._connectionState=HubConnectionState.Disconnecting,this._logger.log(LogLevel.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(LogLevel.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(t===HubConnectionState.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=e||new AbortError("The connection was stopped before the hub handshake could complete."),this.connection.stop(e))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(e,...t){const[n,o]=this._replaceStreamingParams(t),i=this._createStreamInvocation(e,t,o);let s;const r=new Subject;return r.cancelCallback=()=>{const e=this._createCancelInvocation(i.invocationId);return delete this._callbacks[i.invocationId],s.then((()=>this._sendWithProtocol(e)))},this._callbacks[i.invocationId]=(e,t)=>{t?r.error(t):e&&(e.type===MessageType.Completion?e.error?r.error(new Error(e.error)):r.complete():r.next(e.item))},s=this._sendWithProtocol(i).catch((e=>{r.error(e),delete this._callbacks[i.invocationId]})),this._launchStreams(n,s),r}_sendMessage(e){return this._resetKeepAliveInterval(),this.connection.send(e)}_sendWithProtocol(e){return this._messageBuffer?this._messageBuffer._send(e):this._sendMessage(this._protocol.writeMessage(e))}send(e,...t){const[n,o]=this._replaceStreamingParams(t),i=this._sendWithProtocol(this._createInvocation(e,t,!0,o));return this._launchStreams(n,i),i}invoke(e,...t){const[n,o]=this._replaceStreamingParams(t),i=this._createInvocation(e,t,!1,o);return new Promise(((e,t)=>{this._callbacks[i.invocationId]=(n,o)=>{o?t(o):n&&(n.type===MessageType.Completion?n.error?t(new Error(n.error)):e(n.result):t(new Error(`Unexpected message type: ${n.type}`)))};const o=this._sendWithProtocol(i).catch((e=>{t(e),delete this._callbacks[i.invocationId]}));this._launchStreams(n,o)}))}on(e,t){e&&t&&(e=e.toLowerCase(),this._methods[e]||(this._methods[e]=[]),-1===this._methods[e].indexOf(t)&&this._methods[e].push(t))}off(e,t){if(!e)return;e=e.toLowerCase();const n=this._methods[e];if(n)if(t){const o=n.indexOf(t);-1!==o&&(n.splice(o,1),0===n.length&&delete this._methods[e])}else delete this._methods[e]}onclose(e){e&&this._closedCallbacks.push(e)}onreconnecting(e){e&&this._reconnectingCallbacks.push(e)}onreconnected(e){e&&this._reconnectedCallbacks.push(e)}_processIncomingData(e){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(e=this._processHandshakeResponse(e),this._receivedHandshakeResponse=!0),e){const t=this._protocol.parseMessages(e,this._logger);for(const e of t)if(!this._messageBuffer||this._messageBuffer._shouldProcessMessage(e))switch(e.type){case MessageType.Invocation:this._invokeClientMethod(e).catch((e=>{this._logger.log(LogLevel.Error,`Invoke client method threw error: ${getErrorString(e)}`)}));break;case MessageType.StreamItem:case MessageType.Completion:{const t=this._callbacks[e.invocationId];if(t){e.type===MessageType.Completion&&delete this._callbacks[e.invocationId];try{t(e)}catch(e){this._logger.log(LogLevel.Error,`Stream callback threw error: ${getErrorString(e)}`)}}break}case MessageType.Ping:break;case MessageType.Close:{this._logger.log(LogLevel.Information,"Close message received from server.");const t=e.error?new Error("Server returned an error on close: "+e.error):void 0;!0===e.allowReconnect?this.connection.stop(t):this._stopPromise=this._stopInternal(t);break}case MessageType.Ack:this._messageBuffer&&this._messageBuffer._ack(e);break;case MessageType.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(e);break;default:this._logger.log(LogLevel.Warning,`Invalid message type: ${e.type}.`)}}this._resetTimeoutPeriod()}_processHandshakeResponse(e){let t,n;try{[n,t]=this._handshakeProtocol.parseHandshakeResponse(e)}catch(e){const t="Error parsing handshake response: "+e;this._logger.log(LogLevel.Error,t);const n=new Error(t);throw this._handshakeRejecter(n),n}if(t.error){const e="Server returned handshake error: "+t.error;this._logger.log(LogLevel.Error,e);const n=new Error(e);throw this._handshakeRejecter(n),n}return this._logger.log(LogLevel.Debug,"Server handshake complete."),this._handshakeResolver(),n}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=(new Date).getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!(this.connection.features&&this.connection.features.inherentKeepAlive||(this._timeoutHandle=setTimeout((()=>this.serverTimeout()),this.serverTimeoutInMilliseconds),void 0!==this._pingServerHandle))){let e=this._nextKeepAlive-(new Date).getTime();e<0&&(e=0),this._pingServerHandle=setTimeout((async()=>{if(this._connectionState===HubConnectionState.Connected)try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}}),e)}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(e){const t=e.target.toLowerCase(),n=this._methods[t];if(!n)return this._logger.log(LogLevel.Warning,`No client method with the name '${t}' found.`),void(e.invocationId&&(this._logger.log(LogLevel.Warning,`No result given for '${t}' method and invocation ID '${e.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null))));const o=n.slice(),i=!!e.invocationId;let s,r,c;for(const n of o)try{const o=s;s=await n.apply(this,e.arguments),i&&s&&o&&(this._logger.log(LogLevel.Error,`Multiple results provided for '${t}'. Sending error to server.`),c=this._createCompletionMessage(e.invocationId,"Client provided multiple results.",null)),r=void 0}catch(e){r=e,this._logger.log(LogLevel.Error,`A callback for the method '${t}' threw error '${e}'.`)}c?await this._sendWithProtocol(c):i?(r?c=this._createCompletionMessage(e.invocationId,`${r}`,null):void 0!==s?c=this._createCompletionMessage(e.invocationId,null,s):(this._logger.log(LogLevel.Warning,`No result given for '${t}' method and invocation ID '${e.invocationId}'.`),c=this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(c)):s&&this._logger.log(LogLevel.Error,`Result given for '${t}' method but server is not expecting a result.`)}_connectionClosed(e){this._logger.log(LogLevel.Debug,`HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||e||new AbortError("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(e||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===HubConnectionState.Disconnecting?this._completeClose(e):this._connectionState===HubConnectionState.Connected&&this._reconnectPolicy?this._reconnect(e):this._connectionState===HubConnectionState.Connected&&this._completeClose(e)}_completeClose(e){if(this._connectionStarted){this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(null!=e?e:new Error("Connection closed.")),this._messageBuffer=void 0),Platform.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach((t=>t.apply(this,[e])))}catch(t){this._logger.log(LogLevel.Error,`An onclose callback called with error '${e}' threw error '${t}'.`)}}}async _reconnect(e){const t=Date.now();let n=0,o=void 0!==e?e:new Error("Attempting to reconnect due to a unknown error."),i=this._getNextRetryDelay(n++,0,o);if(null===i)return this._logger.log(LogLevel.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),void this._completeClose(e);if(this._connectionState=HubConnectionState.Reconnecting,e?this._logger.log(LogLevel.Information,`Connection reconnecting because of error '${e}'.`):this._logger.log(LogLevel.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach((t=>t.apply(this,[e])))}catch(t){this._logger.log(LogLevel.Error,`An onreconnecting callback called with error '${e}' threw error '${t}'.`)}if(this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(LogLevel.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==i;){if(this._logger.log(LogLevel.Information,`Reconnect attempt number ${n} will start in ${i} ms.`),await new Promise((e=>{this._reconnectDelayHandle=setTimeout(e,i)})),this._reconnectDelayHandle=void 0,this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(LogLevel.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=HubConnectionState.Connected,this._logger.log(LogLevel.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach((e=>e.apply(this,[this.connection.connectionId])))}catch(e){this._logger.log(LogLevel.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`)}return}catch(e){if(this._logger.log(LogLevel.Information,`Reconnect attempt failed because of error '${e}'.`),this._connectionState!==HubConnectionState.Reconnecting)return this._logger.log(LogLevel.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),void(this._connectionState===HubConnectionState.Disconnecting&&this._completeClose());o=e instanceof Error?e:new Error(e.toString()),i=this._getNextRetryDelay(n++,Date.now()-t,o)}}this._logger.log(LogLevel.Information,`Reconnect retries have been exhausted after ${Date.now()-t} ms and ${n} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(e,t,n){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:t,previousRetryCount:e,retryReason:n})}catch(n){return this._logger.log(LogLevel.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${n}'.`),null}}_cancelCallbacksWithError(e){const t=this._callbacks;this._callbacks={},Object.keys(t).forEach((n=>{const o=t[n];try{o(null,e)}catch(t){this._logger.log(LogLevel.Error,`Stream 'error' callback called with '${e}' threw error: ${getErrorString(t)}`)}}))}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(e,t,n,o){if(n)return 0!==o.length?{arguments:t,streamIds:o,target:e,type:MessageType.Invocation}:{arguments:t,target:e,type:MessageType.Invocation};{const n=this._invocationId;return this._invocationId++,0!==o.length?{arguments:t,invocationId:n.toString(),streamIds:o,target:e,type:MessageType.Invocation}:{arguments:t,invocationId:n.toString(),target:e,type:MessageType.Invocation}}}_launchStreams(e,t){if(0!==e.length){t||(t=Promise.resolve());for(const n in e)e[n].subscribe({complete:()=>{t=t.then((()=>this._sendWithProtocol(this._createCompletionMessage(n))))},error:e=>{let o;o=e instanceof Error?e.message:e&&e.toString?e.toString():"Unknown error",t=t.then((()=>this._sendWithProtocol(this._createCompletionMessage(n,o))))},next:e=>{t=t.then((()=>this._sendWithProtocol(this._createStreamItemMessage(n,e))))}})}}_replaceStreamingParams(e){const t=[],n=[];for(let o=0;o<e.length;o++){const i=e[o];if(this._isObservable(i)){const s=this._invocationId;this._invocationId++,t[s]=i,n.push(s.toString()),e.splice(o,1)}}return[t,n]}_isObservable(e){return e&&e.subscribe&&"function"==typeof e.subscribe}_createStreamInvocation(e,t,n){const o=this._invocationId;return this._invocationId++,0!==n.length?{arguments:t,invocationId:o.toString(),streamIds:n,target:e,type:MessageType.StreamInvocation}:{arguments:t,invocationId:o.toString(),target:e,type:MessageType.StreamInvocation}}_createCancelInvocation(e){return{invocationId:e,type:MessageType.CancelInvocation}}_createStreamItemMessage(e,t){return{invocationId:e,item:t,type:MessageType.StreamItem}}_createCompletionMessage(e,t,n){return t?{error:t,invocationId:e,type:MessageType.Completion}:{invocationId:e,result:n,type:MessageType.Completion}}_createCloseMessage(){return{type:MessageType.Close}}}
//# sourceMappingURL=/sm/f058e62eb1d9b8bda92939922e8b3dd719e7feb5da9123c92fdb9b3537d1d9f3.map