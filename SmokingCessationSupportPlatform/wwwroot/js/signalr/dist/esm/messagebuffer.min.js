/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/@microsoft/signalr@8.0.7/dist/esm/MessageBuffer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{MessageType}from"./IHubProtocol";import{isArrayBuffer}from"./Utils";export class MessageBuffer{constructor(e,s,t){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=e,this._connection=s,this._bufferSize=t}async _send(e){const s=this._protocol.writeMessage(e);let t=Promise.resolve();if(this._isInvocationMessage(e)){this._totalMessageCount++;let e=()=>{},i=()=>{};isArrayBuffer(s)?this._bufferedByteCount+=s.byteLength:this._bufferedByteCount+=s.length,this._bufferedByteCount>=this._bufferSize&&(t=new Promise(((s,t)=>{e=s,i=t}))),this._messages.push(new BufferedItem(s,this._totalMessageCount,e,i))}try{this._reconnectInProgress||await this._connection.send(s)}catch{this._disconnected()}await t}_ack(e){let s=-1;for(let t=0;t<this._messages.length;t++){const i=this._messages[t];if(i._id<=e.sequenceId)s=t,isArrayBuffer(i._message)?this._bufferedByteCount-=i._message.byteLength:this._bufferedByteCount-=i._message.length,i._resolver();else{if(!(this._bufferedByteCount<this._bufferSize))break;i._resolver()}}-1!==s&&(this._messages=this._messages.slice(s+1))}_shouldProcessMessage(e){if(this._waitForSequenceMessage)return e.type===MessageType.Sequence&&(this._waitForSequenceMessage=!1,!0);if(!this._isInvocationMessage(e))return!0;const s=this._nextReceivingSequenceId;return this._nextReceivingSequenceId++,s<=this._latestReceivedSequenceId?(s===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=s,this._ackTimer(),!0)}_resetSequence(e){e.sequenceId>this._nextReceivingSequenceId?this._connection.stop(new Error("Sequence ID greater than amount of messages we've received.")):this._nextReceivingSequenceId=e.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){const e=0!==this._messages.length?this._messages[0]._id:this._totalMessageCount+1;await this._connection.send(this._protocol.writeMessage({type:MessageType.Sequence,sequenceId:e}));const s=this._messages;for(const e of s)await this._connection.send(e._message);this._reconnectInProgress=!1}_dispose(e){null!=e||(e=new Error("Unable to reconnect to server."));for(const s of this._messages)s._rejector(e)}_isInvocationMessage(e){switch(e.type){case MessageType.Invocation:case MessageType.StreamItem:case MessageType.Completion:case MessageType.StreamInvocation:case MessageType.CancelInvocation:return!0;case MessageType.Close:case MessageType.Sequence:case MessageType.Ping:case MessageType.Ack:return!1}}_ackTimer(){void 0===this._ackTimerHandle&&(this._ackTimerHandle=setTimeout((async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:MessageType.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0}),1e3))}}class BufferedItem{constructor(e,s,t,i){this._message=e,this._id=s,this._resolver=t,this._rejector=i}}
//# sourceMappingURL=/sm/31cb2c8d3a7817456318ce589c8c292bc98716db7ab3ee83265b0d77f1d6ddc3.map