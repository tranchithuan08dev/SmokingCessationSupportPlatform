/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@microsoft/signalr@8.0.7/dist/cjs/MessageBuffer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MessageBuffer=void 0;const IHubProtocol_1=require("./IHubProtocol"),Utils_1=require("./Utils");class MessageBuffer{constructor(e,s,t){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=e,this._connection=s,this._bufferSize=t}async _send(e){const s=this._protocol.writeMessage(e);let t=Promise.resolve();if(this._isInvocationMessage(e)){this._totalMessageCount++;let e=()=>{},o=()=>{};(0,Utils_1.isArrayBuffer)(s)?this._bufferedByteCount+=s.byteLength:this._bufferedByteCount+=s.length,this._bufferedByteCount>=this._bufferSize&&(t=new Promise(((s,t)=>{e=s,o=t}))),this._messages.push(new BufferedItem(s,this._totalMessageCount,e,o))}try{this._reconnectInProgress||await this._connection.send(s)}catch{this._disconnected()}await t}_ack(e){let s=-1;for(let t=0;t<this._messages.length;t++){const o=this._messages[t];if(o._id<=e.sequenceId)s=t,(0,Utils_1.isArrayBuffer)(o._message)?this._bufferedByteCount-=o._message.byteLength:this._bufferedByteCount-=o._message.length,o._resolver();else{if(!(this._bufferedByteCount<this._bufferSize))break;o._resolver()}}-1!==s&&(this._messages=this._messages.slice(s+1))}_shouldProcessMessage(e){if(this._waitForSequenceMessage)return e.type===IHubProtocol_1.MessageType.Sequence&&(this._waitForSequenceMessage=!1,!0);if(!this._isInvocationMessage(e))return!0;const s=this._nextReceivingSequenceId;return this._nextReceivingSequenceId++,s<=this._latestReceivedSequenceId?(s===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=s,this._ackTimer(),!0)}_resetSequence(e){e.sequenceId>this._nextReceivingSequenceId?this._connection.stop(new Error("Sequence ID greater than amount of messages we've received.")):this._nextReceivingSequenceId=e.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){const e=0!==this._messages.length?this._messages[0]._id:this._totalMessageCount+1;await this._connection.send(this._protocol.writeMessage({type:IHubProtocol_1.MessageType.Sequence,sequenceId:e}));const s=this._messages;for(const e of s)await this._connection.send(e._message);this._reconnectInProgress=!1}_dispose(e){null!=e||(e=new Error("Unable to reconnect to server."));for(const s of this._messages)s._rejector(e)}_isInvocationMessage(e){switch(e.type){case IHubProtocol_1.MessageType.Invocation:case IHubProtocol_1.MessageType.StreamItem:case IHubProtocol_1.MessageType.Completion:case IHubProtocol_1.MessageType.StreamInvocation:case IHubProtocol_1.MessageType.CancelInvocation:return!0;case IHubProtocol_1.MessageType.Close:case IHubProtocol_1.MessageType.Sequence:case IHubProtocol_1.MessageType.Ping:case IHubProtocol_1.MessageType.Ack:return!1}}_ackTimer(){void 0===this._ackTimerHandle&&(this._ackTimerHandle=setTimeout((async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:IHubProtocol_1.MessageType.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0}),1e3))}}exports.MessageBuffer=MessageBuffer;class BufferedItem{constructor(e,s,t,o){this._message=e,this._id=s,this._resolver=t,this._rejector=o}}
//# sourceMappingURL=/sm/77dff1d1ce1efa3922b4e138343e8315c939cf7dc51fe563a9d178904c0c7b38.map