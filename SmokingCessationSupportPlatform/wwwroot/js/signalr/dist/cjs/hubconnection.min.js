/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@microsoft/signalr@8.0.7/dist/cjs/HubConnection.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HubConnection=exports.HubConnectionState=void 0;const HandshakeProtocol_1=require("./HandshakeProtocol"),Errors_1=require("./Errors"),IHubProtocol_1=require("./IHubProtocol"),ILogger_1=require("./ILogger"),Subject_1=require("./Subject"),Utils_1=require("./Utils"),MessageBuffer_1=require("./MessageBuffer"),DEFAULT_TIMEOUT_IN_MS=3e4,DEFAULT_PING_INTERVAL_IN_MS=15e3,DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE=1e5;var HubConnectionState;!function(e){e.Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Disconnecting="Disconnecting",e.Reconnecting="Reconnecting"}(HubConnectionState=exports.HubConnectionState||(exports.HubConnectionState={}));class HubConnection{static create(e,t,o,n,r,i,s){return new HubConnection(e,t,o,n,r,i,s)}constructor(e,t,o,n,r,i,s){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(ILogger_1.LogLevel.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},Utils_1.Arg.isRequired(e,"connection"),Utils_1.Arg.isRequired(t,"logger"),Utils_1.Arg.isRequired(o,"protocol"),this.serverTimeoutInMilliseconds=null!=r?r:3e4,this.keepAliveIntervalInMilliseconds=null!=i?i:15e3,this._statefulReconnectBufferSize=null!=s?s:1e5,this._logger=t,this._protocol=o,this.connection=e,this._reconnectPolicy=n,this._handshakeProtocol=new HandshakeProtocol_1.HandshakeProtocol,this.connection.onreceive=e=>this._processIncomingData(e),this.connection.onclose=e=>this._connectionClosed(e),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:IHubProtocol_1.MessageType.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(e){if(this._connectionState!==HubConnectionState.Disconnected&&this._connectionState!==HubConnectionState.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!e)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=e}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==HubConnectionState.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=HubConnectionState.Connecting,this._logger.log(ILogger_1.LogLevel.Debug,"Starting HubConnection.");try{await this._startInternal(),Utils_1.Platform.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=HubConnectionState.Connected,this._connectionStarted=!0,this._logger.log(ILogger_1.LogLevel.Debug,"HubConnection connected successfully.")}catch(e){return this._connectionState=HubConnectionState.Disconnected,this._logger.log(ILogger_1.LogLevel.Debug,`HubConnection failed to start successfully because of error '${e}'.`),Promise.reject(e)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;const e=new Promise(((e,t)=>{this._handshakeResolver=e,this._handshakeRejecter=t}));await this.connection.start(this._protocol.transferFormat);try{let t=this._protocol.version;this.connection.features.reconnect||(t=1);const o={protocol:this._protocol.name,version:t};if(this._logger.log(ILogger_1.LogLevel.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(o)),this._logger.log(ILogger_1.LogLevel.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await e,this._stopDuringStartError)throw this._stopDuringStartError;(this.connection.features.reconnect||!1)&&(this._messageBuffer=new MessageBuffer_1.MessageBuffer(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(e){throw this._logger.log(ILogger_1.LogLevel.Debug,`Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(e),e}}async stop(){const e=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await e}catch(e){}}_stopInternal(e){if(this._connectionState===HubConnectionState.Disconnected)return this._logger.log(ILogger_1.LogLevel.Debug,`Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===HubConnectionState.Disconnecting)return this._logger.log(ILogger_1.LogLevel.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;const t=this._connectionState;return this._connectionState=HubConnectionState.Disconnecting,this._logger.log(ILogger_1.LogLevel.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(ILogger_1.LogLevel.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(t===HubConnectionState.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=e||new Errors_1.AbortError("The connection was stopped before the hub handshake could complete."),this.connection.stop(e))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(e,...t){const[o,n]=this._replaceStreamingParams(t),r=this._createStreamInvocation(e,t,n);let i;const s=new Subject_1.Subject;return s.cancelCallback=()=>{const e=this._createCancelInvocation(r.invocationId);return delete this._callbacks[r.invocationId],i.then((()=>this._sendWithProtocol(e)))},this._callbacks[r.invocationId]=(e,t)=>{t?s.error(t):e&&(e.type===IHubProtocol_1.MessageType.Completion?e.error?s.error(new Error(e.error)):s.complete():s.next(e.item))},i=this._sendWithProtocol(r).catch((e=>{s.error(e),delete this._callbacks[r.invocationId]})),this._launchStreams(o,i),s}_sendMessage(e){return this._resetKeepAliveInterval(),this.connection.send(e)}_sendWithProtocol(e){return this._messageBuffer?this._messageBuffer._send(e):this._sendMessage(this._protocol.writeMessage(e))}send(e,...t){const[o,n]=this._replaceStreamingParams(t),r=this._sendWithProtocol(this._createInvocation(e,t,!0,n));return this._launchStreams(o,r),r}invoke(e,...t){const[o,n]=this._replaceStreamingParams(t),r=this._createInvocation(e,t,!1,n);return new Promise(((e,t)=>{this._callbacks[r.invocationId]=(o,n)=>{n?t(n):o&&(o.type===IHubProtocol_1.MessageType.Completion?o.error?t(new Error(o.error)):e(o.result):t(new Error(`Unexpected message type: ${o.type}`)))};const n=this._sendWithProtocol(r).catch((e=>{t(e),delete this._callbacks[r.invocationId]}));this._launchStreams(o,n)}))}on(e,t){e&&t&&(e=e.toLowerCase(),this._methods[e]||(this._methods[e]=[]),-1===this._methods[e].indexOf(t)&&this._methods[e].push(t))}off(e,t){if(!e)return;e=e.toLowerCase();const o=this._methods[e];if(o)if(t){const n=o.indexOf(t);-1!==n&&(o.splice(n,1),0===o.length&&delete this._methods[e])}else delete this._methods[e]}onclose(e){e&&this._closedCallbacks.push(e)}onreconnecting(e){e&&this._reconnectingCallbacks.push(e)}onreconnected(e){e&&this._reconnectedCallbacks.push(e)}_processIncomingData(e){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(e=this._processHandshakeResponse(e),this._receivedHandshakeResponse=!0),e){const t=this._protocol.parseMessages(e,this._logger);for(const e of t)if(!this._messageBuffer||this._messageBuffer._shouldProcessMessage(e))switch(e.type){case IHubProtocol_1.MessageType.Invocation:this._invokeClientMethod(e).catch((e=>{this._logger.log(ILogger_1.LogLevel.Error,`Invoke client method threw error: ${(0,Utils_1.getErrorString)(e)}`)}));break;case IHubProtocol_1.MessageType.StreamItem:case IHubProtocol_1.MessageType.Completion:{const t=this._callbacks[e.invocationId];if(t){e.type===IHubProtocol_1.MessageType.Completion&&delete this._callbacks[e.invocationId];try{t(e)}catch(e){this._logger.log(ILogger_1.LogLevel.Error,`Stream callback threw error: ${(0,Utils_1.getErrorString)(e)}`)}}break}case IHubProtocol_1.MessageType.Ping:break;case IHubProtocol_1.MessageType.Close:{this._logger.log(ILogger_1.LogLevel.Information,"Close message received from server.");const t=e.error?new Error("Server returned an error on close: "+e.error):void 0;!0===e.allowReconnect?this.connection.stop(t):this._stopPromise=this._stopInternal(t);break}case IHubProtocol_1.MessageType.Ack:this._messageBuffer&&this._messageBuffer._ack(e);break;case IHubProtocol_1.MessageType.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(e);break;default:this._logger.log(ILogger_1.LogLevel.Warning,`Invalid message type: ${e.type}.`)}}this._resetTimeoutPeriod()}_processHandshakeResponse(e){let t,o;try{[o,t]=this._handshakeProtocol.parseHandshakeResponse(e)}catch(e){const t="Error parsing handshake response: "+e;this._logger.log(ILogger_1.LogLevel.Error,t);const o=new Error(t);throw this._handshakeRejecter(o),o}if(t.error){const e="Server returned handshake error: "+t.error;this._logger.log(ILogger_1.LogLevel.Error,e);const o=new Error(e);throw this._handshakeRejecter(o),o}return this._logger.log(ILogger_1.LogLevel.Debug,"Server handshake complete."),this._handshakeResolver(),o}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=(new Date).getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!(this.connection.features&&this.connection.features.inherentKeepAlive||(this._timeoutHandle=setTimeout((()=>this.serverTimeout()),this.serverTimeoutInMilliseconds),void 0!==this._pingServerHandle))){let e=this._nextKeepAlive-(new Date).getTime();e<0&&(e=0),this._pingServerHandle=setTimeout((async()=>{if(this._connectionState===HubConnectionState.Connected)try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}}),e)}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(e){const t=e.target.toLowerCase(),o=this._methods[t];if(!o)return this._logger.log(ILogger_1.LogLevel.Warning,`No client method with the name '${t}' found.`),void(e.invocationId&&(this._logger.log(ILogger_1.LogLevel.Warning,`No result given for '${t}' method and invocation ID '${e.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null))));const n=o.slice(),r=!!e.invocationId;let i,s,c;for(const o of n)try{const n=i;i=await o.apply(this,e.arguments),r&&i&&n&&(this._logger.log(ILogger_1.LogLevel.Error,`Multiple results provided for '${t}'. Sending error to server.`),c=this._createCompletionMessage(e.invocationId,"Client provided multiple results.",null)),s=void 0}catch(e){s=e,this._logger.log(ILogger_1.LogLevel.Error,`A callback for the method '${t}' threw error '${e}'.`)}c?await this._sendWithProtocol(c):r?(s?c=this._createCompletionMessage(e.invocationId,`${s}`,null):void 0!==i?c=this._createCompletionMessage(e.invocationId,null,i):(this._logger.log(ILogger_1.LogLevel.Warning,`No result given for '${t}' method and invocation ID '${e.invocationId}'.`),c=this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(c)):i&&this._logger.log(ILogger_1.LogLevel.Error,`Result given for '${t}' method but server is not expecting a result.`)}_connectionClosed(e){this._logger.log(ILogger_1.LogLevel.Debug,`HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||e||new Errors_1.AbortError("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(e||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===HubConnectionState.Disconnecting?this._completeClose(e):this._connectionState===HubConnectionState.Connected&&this._reconnectPolicy?this._reconnect(e):this._connectionState===HubConnectionState.Connected&&this._completeClose(e)}_completeClose(e){if(this._connectionStarted){this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(null!=e?e:new Error("Connection closed.")),this._messageBuffer=void 0),Utils_1.Platform.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach((t=>t.apply(this,[e])))}catch(t){this._logger.log(ILogger_1.LogLevel.Error,`An onclose callback called with error '${e}' threw error '${t}'.`)}}}async _reconnect(e){const t=Date.now();let o=0,n=void 0!==e?e:new Error("Attempting to reconnect due to a unknown error."),r=this._getNextRetryDelay(o++,0,n);if(null===r)return this._logger.log(ILogger_1.LogLevel.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),void this._completeClose(e);if(this._connectionState=HubConnectionState.Reconnecting,e?this._logger.log(ILogger_1.LogLevel.Information,`Connection reconnecting because of error '${e}'.`):this._logger.log(ILogger_1.LogLevel.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach((t=>t.apply(this,[e])))}catch(t){this._logger.log(ILogger_1.LogLevel.Error,`An onreconnecting callback called with error '${e}' threw error '${t}'.`)}if(this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(ILogger_1.LogLevel.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==r;){if(this._logger.log(ILogger_1.LogLevel.Information,`Reconnect attempt number ${o} will start in ${r} ms.`),await new Promise((e=>{this._reconnectDelayHandle=setTimeout(e,r)})),this._reconnectDelayHandle=void 0,this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(ILogger_1.LogLevel.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=HubConnectionState.Connected,this._logger.log(ILogger_1.LogLevel.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach((e=>e.apply(this,[this.connection.connectionId])))}catch(e){this._logger.log(ILogger_1.LogLevel.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`)}return}catch(e){if(this._logger.log(ILogger_1.LogLevel.Information,`Reconnect attempt failed because of error '${e}'.`),this._connectionState!==HubConnectionState.Reconnecting)return this._logger.log(ILogger_1.LogLevel.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),void(this._connectionState===HubConnectionState.Disconnecting&&this._completeClose());n=e instanceof Error?e:new Error(e.toString()),r=this._getNextRetryDelay(o++,Date.now()-t,n)}}this._logger.log(ILogger_1.LogLevel.Information,`Reconnect retries have been exhausted after ${Date.now()-t} ms and ${o} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(e,t,o){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:t,previousRetryCount:e,retryReason:o})}catch(o){return this._logger.log(ILogger_1.LogLevel.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${o}'.`),null}}_cancelCallbacksWithError(e){const t=this._callbacks;this._callbacks={},Object.keys(t).forEach((o=>{const n=t[o];try{n(null,e)}catch(t){this._logger.log(ILogger_1.LogLevel.Error,`Stream 'error' callback called with '${e}' threw error: ${(0,Utils_1.getErrorString)(t)}`)}}))}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(e,t,o,n){if(o)return 0!==n.length?{arguments:t,streamIds:n,target:e,type:IHubProtocol_1.MessageType.Invocation}:{arguments:t,target:e,type:IHubProtocol_1.MessageType.Invocation};{const o=this._invocationId;return this._invocationId++,0!==n.length?{arguments:t,invocationId:o.toString(),streamIds:n,target:e,type:IHubProtocol_1.MessageType.Invocation}:{arguments:t,invocationId:o.toString(),target:e,type:IHubProtocol_1.MessageType.Invocation}}}_launchStreams(e,t){if(0!==e.length){t||(t=Promise.resolve());for(const o in e)e[o].subscribe({complete:()=>{t=t.then((()=>this._sendWithProtocol(this._createCompletionMessage(o))))},error:e=>{let n;n=e instanceof Error?e.message:e&&e.toString?e.toString():"Unknown error",t=t.then((()=>this._sendWithProtocol(this._createCompletionMessage(o,n))))},next:e=>{t=t.then((()=>this._sendWithProtocol(this._createStreamItemMessage(o,e))))}})}}_replaceStreamingParams(e){const t=[],o=[];for(let n=0;n<e.length;n++){const r=e[n];if(this._isObservable(r)){const i=this._invocationId;this._invocationId++,t[i]=r,o.push(i.toString()),e.splice(n,1)}}return[t,o]}_isObservable(e){return e&&e.subscribe&&"function"==typeof e.subscribe}_createStreamInvocation(e,t,o){const n=this._invocationId;return this._invocationId++,0!==o.length?{arguments:t,invocationId:n.toString(),streamIds:o,target:e,type:IHubProtocol_1.MessageType.StreamInvocation}:{arguments:t,invocationId:n.toString(),target:e,type:IHubProtocol_1.MessageType.StreamInvocation}}_createCancelInvocation(e){return{invocationId:e,type:IHubProtocol_1.MessageType.CancelInvocation}}_createStreamItemMessage(e,t){return{invocationId:e,item:t,type:IHubProtocol_1.MessageType.StreamItem}}_createCompletionMessage(e,t,o){return t?{error:t,invocationId:e,type:IHubProtocol_1.MessageType.Completion}:{invocationId:e,result:o,type:IHubProtocol_1.MessageType.Completion}}_createCloseMessage(){return{type:IHubProtocol_1.MessageType.Close}}}exports.HubConnection=HubConnection;
//# sourceMappingURL=/sm/c31fbd8500ef820ed8a905b0ff7fbfb68ba7fe54a31fbf0ec5df2794dab35876.map